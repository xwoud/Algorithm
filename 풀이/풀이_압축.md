# 🪤 프로그래머스 압축
- Date : 2021.02.14(일)
- Time : 20분
<br>

## 문제

- 신입사원 어피치는 카카오톡으로 전송되는 메시지를 압축하여 전송 효율을 높이는 업무를 맡게 되었다. 메시지를 압축하더라도 전달되는 정보가 바뀌어서는 안 되므로, 압축 전의 정보를 완벽하게 복원 가능한 무손실 압축 알고리즘을 구현하기로 했다.
어피치는 여러 압축 알고리즘 중에서 성능이 좋고 구현이 간단한 LZW(Lempel–Ziv–Welch) 압축을 구현하기로 했다. LZW 압축은 1983년 발표된 알고리즘으로, 이미지 파일 포맷인 GIF 등 다양한 응용에서 사용되었다.
LZW 압축은 다음 과정을 거친다.
1. 길이가 1인 모든 단어를 포함하도록 사전을 초기화한다.
2. 사전에서 현재 입력과 일치하는 가장 긴 문자열 w를 찾는다.
3. w에 해당하는 사전의 색인 번호를 출력하고, 입력에서 w를 제거한다.
4. 입력에서 처리되지 않은 다음 글자가 남아있다면(c), w+c에 해당하는 단어를 사전에 등록한다.
5. 단계 2로 돌아간다.

- 압축 알고리즘이 영문 대문자만 처리한다고 할 때, 사전은 다음과 같이 초기화된다. 사전의 색인 번호는 정수값으로 주어지며, 1부터 시작한다고 하자.
<br><br>

## 코드 풀이

```python
    referee = [] #사전에 글자가 있는지 확인 할 배열
    answer = [] #색인 번호 저장 배열
    msg = list(msg) # 문자열 배열
    rule = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']
    # 사전 배열
```
: 다른 풀이를 보니 사전을 딕셔너리 형태로 저장하는 사람들이 많았다. 앞에 숫자를 같이 쓸 수 있어서 그렇게 한 듯하다. 근데 index + 1 이 사전 번호이기 때문에 배열로 구현해보았다. 

```python
    while msg :
    # 검사 할 문자열이 남아있을 때까지 진행한다. 
        referee.append(msg.pop(0))
        # 이 곳에서는 referee가 비어있는 상태이기 때문에 검사할 문자열 하나를 넣어준다. 
        while referee :
            # 검사할 문자열이 있는 동안 진행한다.
            if ''.join(referee) in rule :
            # 사전에 있는 문자라면
                if len(msg) > 0 :
                    # 아직 남아있는 문자열이 있다면 뒤에 붙여서 더 검사를 진행한다.
                    referee.append(msg.pop(0))
                else :
                    # 마지막 문자열이였다면 사전 index를 저장한 후 모든 while문을 완전히 빠져나간다.
                    answer.append(rule.index(''.join(referee)) + 1)
                    break
            else :
            # 사전에 존재하지 않는 문자라면
                rule.append(''.join(referee))
                # 사전에 저장한다.
                msg.insert(0,referee.pop(-1))
                # 맨 뒤에 글자만 다시 문자열로 돌려놓고 referee에서 제외시킨다.
                answer.append(rule.index(''.join(referee)) + 1)
                # 남아있는 referee의 사전 index를 저장한다.
                referee = []
                # referee를 초기화한다.
```