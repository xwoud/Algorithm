# 🥭 프로그래머스 로또의 최고 순위와 최저 순위
- Date : 2021.05.09(일)
- Time : 10분
<br>

## 문제

- 로또를 구매한 민우는 당첨 번호 발표일을 학수고대하고 있었습니다. 하지만, 민우의 동생이 로또에 낙서를 하여, 일부 번호를 알아볼 수 없게 되었습니다. 당첨 번호 발표 후, 민우는 자신이 구매했던 로또로 당첨이 가능했던 최고 순위와 최저 순위를 알아보고 싶어 졌습니다.
    - 순서와 상관없이, 구매한 로또에 당첨 번호와 일치하는 번호가 있으면 맞힌 걸로 인정됩니다.
    - 알아볼 수 없는 두 개의 번호를 각각 10, 6이라고 가정하면 3등에 당첨될 수 있습니다.
        - 3등을 만드는 다른 방법들도 존재합니다. 하지만, 2등 이상으로 만드는 것은 불가능합니다.
    - 알아볼 수 없는 두 개의 번호를 각각 11, 7이라고 가정하면 5등에 당첨될 수 있습니다.
        - 5등을 만드는 다른 방법들도 존재합니다. 하지만, 6등(낙첨)으로 만드는 것은 불가능합니다.

    민우가 구매한 로또 번호를 담은 배열 lottos, 당첨 번호를 담은 배열 win_nums가 매개변수로 주어집니다. 이때, 당첨 가능한 최고 순위와 최저 순위를 차례대로 배열에 담아서 return 하도록 solution 함수를 완성해주세요.



## 제한사항
- lottos는 길이 6인 정수 배열입니다.
- lottos의 모든 원소는 0 이상 45 이하인 정수입니다.
    - 0은 알아볼 수 없는 숫자를 의미합니다.
    - 0을 제외한 다른 숫자들은 lottos에 2개 이상 담겨있지 않습니다.
    - lottos의 원소들은 정렬되어 있지 않을 수도 있습니다.
- win_nums은 길이 6인 정수 배열입니다.
- win_nums의 모든 원소는 1 이상 45 이하인 정수입니다.
    - win_nums에는 같은 숫자가 2개 이상 담겨있지 않습니다.
    - win_nums의 원소들은 정렬되어 있지 않을 수도 있습니다.

<br><br>

## 코드 풀이

```python
    rank = [6, 6, 5, 4, 3, 2, 1]
    answer = []
    defalut = 0
    lottos.sort()

    for i in range(len(lottos)-1,-1,-1):
        if lottos[i] in win_nums:
            defalut += 1
            win_nums.remove(lottos[i])
            lottos.pop()
        elif lottos[i] != 0:
            lottos.pop()
    answer.append(rank[defalut])
```
: 먼저 최저 순위를 구해준다. 민우가 구매한 로또 번호를 먼저 정렬하고 뒤에서부터 검사를 해준다. 만약 당첨 번호라면 default 에 1을 더해주고 그 숫자는 두 배열에서 모두 제외해준다 (win_nums에서 제외하는 이유는 중복된 숫자로 당첨될 수 없기 때문!). 당첨 번호도 아니고 0도 아니면 그 숫자는 쓸때없는 숫자이므로 배열에서 제외시킨다. 이렇게하면 default의 숫자는 최저 당첨 갯수가 나온다.

``` python
    if len(lottos) <= len(win_nums):
        defalut += len(lottos)
    else :
        defalut += len(win_nums)

    answer.append(rank[defalut])

    answer.reverse()

    return answer
```
: 이제 최고 당첨 순위를 구해야한다. 일단 lottos에는 0을 제외한 모든 숫자들이 없어져있을 것이다. 그렇기 때문에 len(lottos)를 검사해서 만약 남은 당첨 리스트보다 작다면 이 숫자들은 모두 당첨될 수 있는 경우의 수기 때문에 더해준다. 만약 크다면 남은 win_nums 의 숫자만큼만 당첨될 수 있기 때문에(중복 숫자가 안되기 때문에) 그만큼만 더해준다. 이렇게 하면 answer에 [최저순위, 최고순위] 로 저장이 되기 때문에 reverse를 이용해 뒤집어준다. 
