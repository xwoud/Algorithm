# 🦊 2022 KAKAO BLIND RECRUITMENT - 주차 요금 계산
- Date : 2022.03.05(토)
- Time : 40분
- Language : Python
<br>

## [Problem](https://programmers.co.kr/learn/courses/30/lessons/92341)
- 주차장의 요금표와 차량이 들어오고(입차) 나간(출차) 기록이 주어졌을 때, 차량별로 주차 요금을 계산하려고 합니다. 아래는 하나의 예시를 나타냅니다.
- 요금표
    |기본 시간(분)	|기본 요금(원)|	단위 시간(분)	|단위 요금(원)|
    | ------------ | ------------ | ------------ |------------ |
    |180	|5000|	10|	600|
- 입/출차 기록
    |시각(시:분)|	차량 번호	|내역|
    | ------------ | ------------ |------------ |
    |05:34	|5961|	입차|
    |06:00|	0000|	입차|
    |06:34|	0000|	출차|
    |07:59|	5961|	출차|
    |07:59|	0148|	입차|
    |18:59|	0000|	입차|
    |19:09|	0148|	출차|
    |22:59|	5961|	입차|
    |23:00|	5961|	출차|
- 자동차별 주차 요금
    |차량 번호|	누적 주차 시간(분)|	주차 요금(원)|
    | ------------ | ------------ |------------ |
    |0000	|34 + 300 = 334|	5000 + ⌈(334 - 180) / 10⌉ x 600 = 14600|
    |0148|	670|	5000 +⌈(670 - 180) / 10⌉x 600 = 34400|
    |5961|	145 + 1 = 146|	5000|
    - 어떤 차량이 입차된 후에 출차된 내역이 없다면, 23:59에 출차된 것으로 간주합니다.
        - 0000번 차량은 18:59에 입차된 이후, 출차된 내역이 없습니다. 따라서, 23:59에 출차된 것으로 간주합니다.
    - 00:00부터 23:59까지의 입/출차 내역을 바탕으로 차량별 누적 주차 시간을 계산하여 요금을 일괄로 정산합니다.
    - 누적 주차 시간이 기본 시간이하라면, 기본 요금을 청구합니다.
    - 누적 주차 시간이 기본 시간을 초과하면, 기본 요금에 더해서, 초과한 시간에 대해서 단위 시간 마다 단위 요금을 청구합니다.
        - 초과한 시간이 단위 시간으로 나누어 떨어지지 않으면, 올림합니다.
        - ⌈a⌉ : a보다 작지 않은 최소의 정수를 의미합니다. 즉, 올림을 의미합니다.
- 주차 요금을 나타내는 정수 배열 fees, 자동차의 입/출차 내역을 나타내는 문자열 배열 records가 매개변수로 주어집니다. 차량 번호가 작은 자동차부터 청구할 주차 요금을 차례대로 정수 배열에 담아서 return 하도록 solution 함수를 완성해주세요.

## Constraints
- fees의 길이 = 4
    - fees[0] = 기본 시간(분)
    - 1 ≤ fees[0] ≤ 1,439
    - fees[1] = 기본 요금(원)
    - 0 ≤ fees[1] ≤ 100,000
    - fees[2] = 단위 시간(분)
    - 1 ≤ fees[2] ≤ 1,439
    - fees[3] = 단위 요금(원)
    - 1 ≤ fees[3] ≤ 10,000
- 1 ≤ records의 길이 ≤ 1,000
    - records의 각 원소는 "시각 차량번호 내역" 형식의 문자열입니다.
    - 시각, 차량번호, 내역은 하나의 공백으로 구분되어 있습니다.
    - 시각은 차량이 입차되거나 출차된 시각을 나타내며, HH:MM 형식의 길이 5인 문자열입니다.
        - HH:MM은 00:00부터 23:59까지 주어집니다.
        - 잘못된 시각("25:22", "09:65" 등)은 입력으로 주어지지 않습니다.
    - 차량번호는 자동차를 구분하기 위한, `0'~'9'로 구성된 길이 4인 문자열입니다.
    - 내역은 길이 2 또는 3인 문자열로, IN 또는 OUT입니다. IN은 입차를, OUT은 출차를 의미합니다.
    - records의 원소들은 시각을 기준으로 오름차순으로 정렬되어 주어집니다.
    - records는 하루 동안의 입/출차된 기록만 담고 있으며, 입차된 차량이 다음날 출차되는 경우는 입력으로 주어지지 않습니다.
    - 같은 시각에, 같은 차량번호의 내역이 2번 이상 나타내지 않습니다.
    - 마지막 시각(23:59)에 입차되는 경우는 입력으로 주어지지 않습니다.
    - 아래의 예를 포함하여, 잘못된 입력은 주어지지 않습니다.
        - 주차장에 없는 차량이 출차되는 경우
        - 주차장에 이미 있는 차량(차량번호가 같은 차량)이 다시 입차되는 경우

## Example
|fees	|records|	result|
| ------------ | ------------ |------------ |
|[180, 5000, 10, 600]|	["05:34 5961 IN", "06:00 0000 IN", "06:34 0000 OUT", "07:59 5961 OUT", "07:59 0148 IN", "18:59 0000 IN", "19:09 0148 OUT", "22:59 5961 IN", "23:00 5961 OUT"]	|[14600, 34400, 5000]|
|[120, 0, 60, 591]|	["16:00 3961 IN","16:00 0202 IN","18:00 3961 OUT","18:00 0202 OUT","23:58 3961 IN"]	|[0, 591]|
|[1, 461, 1, 10]|	["00:00 1234 IN"]	|[14841]|


<br>

## 풀이
```python
import math

def timeConvert(time):
    a, b = time.split(':')
    return int(a) * 60 + int(b)
    
def solution(fees, records):

    def parkingAccount(account):
        if account <= fees[0] : return fees[1]
        account = account - fees[0]
        return math.ceil(account / fees[2]) * fees[3] + fees[1]

    answer = []
    records = list(map(lambda x: x.split(' '), records))
    records.sort(key= lambda x: (x[1], x[0]))

    dictionary = {string[1] : 0 for string in records}

    for i in records:
        if i[2] == "IN": 
            answer.append(i)
        else: 
            a = answer.pop()
            time = timeConvert(i[0]) - timeConvert(a[0])
            dictionary[i[1]] += time

    for i in answer:
        time = timeConvert("23:59") - timeConvert(i[0])
        dictionary[i[1]] += time
    answer = list(map(lambda x: parkingAccount(x), dictionary.values()))
    
    return answer
```
여기서는 두 가지의 기능이 필요하다. 첫번째는 HH:MM을 MM(분)으로 바꿔주는 함수이다. 두번째는 요금표를 토대로 주차 요금을 계산해주는 함수이다. 이 두가지 함수를 만들고 문제를 풀어보았다.

먼저 records로 받은 자동차의 입/출차 내역을 정렬해주는 것이 필요하다. 현재는 ```"시간 번호 IN/OUT"으로 하나의 문자열로 붙어있는데 이것을 [시간, 번호, IN/OUT]```으로 바꿔주는 과정을 거쳤다. 그 후에 정렬을 하는데 결과를 return 할 때 차량 번호가 작은 순으로 주차 요금을 청구해야하기 때문에, 먼저 차량 번호순으로 정렬을 시도했다. 그리고 같은 차량 안에서는 과거 시간이 앞에 와야하기 때문에 시간 순으로 정렬을 도와주었다.

그리고 결과값(여기서는 차량 번호 별 주차 요금)을 저장하기 위해 ```key = 차량 번호, value = 0(주차 요금이 여기 더해질 예정이다)```으로 dictionary를 제작하였다.

이제 정렬된 records를 가지고 주차 요금을 정산해야한다. 여기서는 Stack을 사용하였다. IN이라면 스택에 append 시켜주고, OUT이라면 스택에서 pop 시켜주었다. 스택을 사용한 이유는 입차 기록은 있지만 출차 기록이 없을 수 있기 때문이다. 출차 기록이 없을 때는 23:59의 시간으로 계산을 해줘야 하기 때문에 스택에 남겨둔 것이다. 먼저 입출차 기록이 매칭될 때가 기준으로 for문을 돌린다. 여기서 OUT을 만난다면 먼저 IN이 무조건 있었을테니, pop() 시켜준 다음에 두 개의 시간을 모두 분으로 변경한 다음에 ```출차 시간에서 입차 시간을 빼준다```. 그리고 그 시간을 위에서 만들어둔 dictionary에 누적해준다. 이 for문을 모두 종료하면 입출차 시간이 짝으로 있는 주차는 시간이 누적되어 있을 것이고, ```입차 시간만 존재한다면 아직 스택에 남아있을 것```이다.

이제 스택에 남은 시간을 처리하기 위해 for문을 한번 더 진행해준다. 여기서는 출차 시간을 23:59으로 잡아준 후에 위의 for문과 같이 계산을 진행해준다.

이제 dictionary의 각 Key값의 value에는 주차 누적 시간이 저장되어 있을 것이다. 이 시간을 요금표와 함께 요금계산을 진행해준다. 요금표는 [기본 시간, 기본 요금, 단위 시간, 단위 요금] 으로 구성되어 있다. 만약 누적 시간이 기본 시간보다 작다면, 기본 요금만 내면 된다. 하지만 기본 시간을 넘는다면 기본 시간을 뺀 나머지는 단위 시간마다 단위 요금을 내야한다. 그러니깐 식이 ```올림(누적시간 / 단위 ) * 단위요금 + 기본 시간```이 되는 것이다. 이 값을 배열에 넣어서 return 하면 된다. 처음 dictionary를 만들 때 차량 번호가 작은 순으로 넣어놨기 때문에 여기서 다시 정렬해줄 필요는 없다.





![IMG_99BEF5329E50-1](https://user-images.githubusercontent.com/51286963/156911403-c3edafaf-501f-4586-b065-fba393024a5f.jpeg)